// Parser by Megan Lucas, Nadia Mahgerefteh and Stars Momodu
import java_cup.runtime.*;

parser code {:

  Boolean syntaxErrors = false;
  Lexer lexer;

  public Parser(Lexer lex) {
    this.lexer = lex;
  } 

  public void syntax_error(Symbol current_token) { report_error(
     "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null );
  }
:}

scan with {: return lexer.next_token(); :};

/* -----------------------------------------------------------------------------------------
 * Terminals
 * -----------------------------------------------------------------------------------------
 */

// ----OTHER----
terminal ERROR, ID, LEN;


// ----PUNCTUATION----

      //  Brackets
      terminal  BRACKET_L, BRACKET_R, BRACKET_SL, BRACKET_SR, ANGLE_R, ANGLE_L, CURLY_R, CURLY_L;
      
      //  Other
      terminal  SEMICOLON, COLON, DOT, COMMA, QUES_MARK;     


// ----KEYWORDS----

      //  Declaration
      terminal  ALIAS, TDEF, FDEF, MAIN;

      //  Control Flow
      terminal  IF, FI, THEN, ELSE, LOOP, POOL, RETURN, BREAK;
      
      //  IO
      terminal  READ, PRINT;


// ----DATA TYPES----

      //  Primitive
      terminal  TYPE_BOOL, TYPE_INT, TYPE_FLOAT, TYPE_RAT, TYPE_CHAR;

      //  Aggregate
      terminal  TYPE_STR, DICT, SEQ;

      //  Other
      terminal  TOP;

// ----LITERALS----

      //  Primitive
      terminal  LIT_BOOL, LIT_POS_INT, LIT_NEG_INT, LIT_CHAR, LIT_FLOAT, LIT_RAT;

      //  Aggregate
      terminal  LIT_STRING;

      //  Other
      terminal  NULL;

// ----OPERATORS----

      //  Boolean Operators
      terminal  NOT, AND, OR, IMPLIES;

      //  Numeric Operators
      terminal  PLUS, MINUS, MULTIPLY, DIVIDE, POWER;

      //  Dictionary/Sequence Operators
      terminal  IN, CONCAT;

      //  Comparison Operators
      terminal  LESS_OR_EQ, EQUAL, NOT_EQUAL;

      //  Other
      terminal ASSIGNMENT;

      
/* -----------------------------------------------------------------------------------------
 * Non Terminals
 * -----------------------------------------------------------------------------------------
 */



// ----˜Z PROGRAM----
  non terminal        Z_Program;



// ----DECLARATIONS----
  non terminal        Declaration, Declaration_list;

  // functions
  non terminal        Declaration_function, Declaration_main;

  // types
  non terminal        Declaration_type, Declaration_type_alias;

  // parameters
  non terminal        Parameter_function, Parameter_list_function, Parameter_type, Parameter_list_type;

  // variables
  non terminal        Declaration_variable, Declaration_variable_assignment;



// ----FUNCTION DECLARATIONS----
  non terminal        Function_body, Main_body;

  // legal declarations
  non terminal        Legal_declaration_function, Legal_declaration_list_function, Legal_declaration_main, Legal_declaration_list_main;



// ----STATEMENTS----

  non terminal        Statement, Statement_list;

  // control flow
  non terminal        Statement_control_flow, Statement_if, Statement_if_else, Statement_loop;

  // actions
  non terminal        Statement_return, Statement_break, Statement_assignment, Statement_conditioned_function_call;

  // input/output
  non terminal        Statement_IO, Statement_input, Statement_output;



// ----EXPRESSIONS----
  non terminal        Expression, Expression_list;

  // operators
  non terminal        Expression_boolean, Expression_comparison, Expression_numeric, Expression_sequence;

  // types
  non terminal        Expression_dictionary, Expression_int, Expression_rat, Expression_float, Expression_string, Expression_defined, Expression_unknown;
  non terminal        Expression_pos_int_unknown, Expression_variable;

  // functions and fields
  non terminal        Expression_function_predicate, Expression_function_call, Expression_conditioned_function_call, Expression_field_reference, Expression_sequence_length;

  // aggregate type value reference
  non terminal        Expression_dictionary_key, Expression_sequence_index; 

  // sequence slice
  non terminal        Expression_sequence_slice, Expression_sequence_left_slice, Expression_sequence_right_slice, Expression_sequence_dual_slice, Expression_sequence_empty_slice;


// ----LITERALS----
  non terminal        Literal;

  // primitive literals
  non terminal        Literal_Integer, Literal_inbuilt;

  // aggregate literals
  non terminal        Literal_dictionary, Dictionary_entry, Dictionary_entry_list, Literal_sequence, Sequence_entry, Sequence_entry_list, Literal_string, Literal_defined;

  // automatically converted numerical literals 
  non terminal        Literal_rational, Literal_float;



// ----TYPES----
  non terminal        Type; 

  // Type grouping
  non terminal        Type_primitive, Type_number, Type_aggregate, Type_defined; // defined type includes aliases

  // aggregate types
  non terminal        Type_dictionary, Type_sequence, Type_string;

  // legal types
  non terminal        Type_legal_dictionary_key, Type_legal_dictionary_value, Type_legal_sequence_value;



// ----OPERATORS----

  non terminal        Operator;

  // binary
  non terminal        Operator_binary_boolean, Operator_binary_comparison, Operator_binary_numeric, Operator_binary_sequence, Operator_binary_dictionary;

  // unary
  non terminal        Operator_unary_boolean;


/* -----------------------------------------------------------------------------------------
 * Precedences
 * -----------------------------------------------------------------------------------------
 */
precedence left       ASSIGNMENT;
precedence nonassoc   ANGLE_L, LESS_OR_EQ, EQUAL, NOT_EQUAL;
precedence left       COLON;
precedence left       PLUS, MINUS, OR, IMPLIES;
precedence left       DIVIDE, MULTIPLY, AND;
precedence left       POWER;
precedence left       DOT, CONCAT, IN;
precedence right      NOT;
precedence left       BRACKET_L, BRACKET_R;


/* -----------------------------------------------------------------------------------------
 * Rules
 * -----------------------------------------------------------------------------------------
 */

start with Z_Program;

// ----˜Z PROGRAM----
Z_Program ::= Declaration_main
            | Declaration_main Declaration_list
            | Declaration_list Declaration_main
            | Declaration_list Declaration_main Declaration_list
            ;
       
// ----DECLARATIONS----
Declaration ::= Declaration_function
              | Declaration_type
              | Declaration_type_alias
              | Declaration_variable
              | Declaration_variable_assignment
              ;

Declaration_list ::= Declaration Declaration_list
                   | Declaration
                   ;


// functions
Declaration_function ::= FDEF ID BRACKET_L Parameter_list_function BRACKET_R CURLY_L Function_body CURLY_R SEMICOLON 
                       | FDEF ID BRACKET_L Parameter_list_function BRACKET_R CURLY_L Function_body CURLY_R COLON Type SEMICOLON
                       | FDEF ID BRACKET_L Parameter_list_function BRACKET_R CURLY_L CURLY_R SEMICOLON // allow empty function if it has no return type
                       ;

Declaration_main ::= MAIN CURLY_L Main_body CURLY_R SEMICOLON;

// types
Declaration_type ::= TDEF ID CURLY_L Parameter_list_type CURLY_R SEMICOLON;

Declaration_type_alias ::= ALIAS Type ID SEMICOLON;

// parameters
Parameter_function ::= ID COLON Type;

Parameter_list_function ::= Parameter_function COMMA Parameter_list_function
                          | Parameter_function;

Parameter_type ::= ID COLON Type;

Parameter_list_type ::= Parameter_type COMMA Parameter_list_type 
                      | Parameter_type
                      ;
// variables
Declaration_variable ::= ID COLON Type ASSIGNMENT Expression SEMICOLON
               //        | ID COLON Type SEMICOLON
                       ;

/*Declaration_variable_assignment ::= ID COLON Type ASSIGNMENT Expression SEMICOLON;*/


// ----FUNCTION DECLARATIONS----
Function_body ::= Legal_declaration_list_function Statement_list
                | Legal_declaration_list_function
                | Statement_list
                ;

/*Main_body ::= Legal_declaration_list_main Statement_list
            | Legal_declaration_list_main
            | Statement_list
            ;*/

// legal declarations
/*Legal_declaration_function ::= Declaration_variable
                             | Declaration_variable_assignment
                             ;*/

Legal_declaration_list_function ::= Declaration_variable Legal_declaration_list_function
                               //   | Declaration_variable Declaration_variable
                                  ;

/*Legal_declaration_main ::= Declaration_variable
                         | Declaration_variable_assignment
                         ;*/

/*Legal_declaration_list_main ::= Declaration_variable Legal_declaration_list_main
                              | Declaration_variable Declaration_variable
                              ;*/

// ----STATEMENTS----
Statement ::= Statement_control_flow
            | Statement_IO
            | Statement_assignment
            | Statement_conditioned_function_call
            | Statement_return
            | Statement_break
            ;

Statement_list ::= Statement Statement_list
                 | Statement
                 ;
// control flow
Statement_control_flow ::= Statement_if
                         | Statement_if_else
                         | Statement_loop
                         ;

Statement_if ::= IF BRACKET_L Expression BRACKET_R THEN Function_body FI;
                                      
Statement_if_else ::= IF BRACKET_L Expression BRACKET_R THEN Function_body ELSE Function_body FI;

Statement_loop ::= LOOP Function_body POOL;

// actions
Statement_break ::= BREAK SEMICOLON
                  | BREAK Expression_pos_int_unknown SEMICOLON
                  ;

Statement_return ::= RETURN Expression SEMICOLON;

Statement_assignment ::= ID ASSIGNMENT Expression SEMICOLON;

Statement_conditioned_function_call ::= Expression_function_predicate Expression_function_call SEMICOLON;

// input/output
Statement_IO ::= Statement_input
               | Statement_output
               ;

Statement_input ::= READ ID SEMICOLON;

Statement_output ::= PRINT Expression SEMICOLON;

// ----EXPRESSIONS----
Expression ::= Expression_boolean 
             | Expression_numeric
             | Expression_sequence
             | Expression_dictionary
             | Expression_defined
             ;

// operators
Expression_boolean ::= LIT_BOOL
                     | Expression_boolean Operator_binary_boolean Expression_boolean
                     | NOT Expression_boolean
                     | Expression IN Expression_sequence
                     | Type_legal_dictionary_key IN Expression_dictionary
                     | Expression_int Operator_binary_comparison Expression_int
                     | Expression_rat Operator_binary_comparison Expression_rat
                     | Expression_float Operator_binary_comparison Expression_float
                     | Expression_boolean Operator_binary_comparison Expression_boolean
                     ;

Expression_int ::= Literal_Integer 
                 | Expression_int Operator_binary_numeric Expression_int
                 | Expression_sequence_length
                // | Expression_unknown
                 ;

Expression_rat ::= Literal_rational
                 | Expression_rat Operator_binary_numeric Expression_rat
                 | Expression_rat Operator_binary_numeric Expression_int
                 | Expression_int Operator_binary_numeric Expression_rat
                 //| Expression_unknown
                 ;

Expression_float ::= Literal_float
                   | Expression_float Operator_binary_numeric Expression_float
                   | Expression_float Operator_binary_numeric Expression_int
                   | Expression_int Operator_binary_numeric Expression_float
                // | Expression_unknown
                   ;

/*Expression_numeric ::= Expression_int
                     | Expression_float
                     | Expression_rat
                     ;*/

Expression_sequence ::= Literal_sequence
                      | Expression_sequence_slice
                      | Expression_sequence CONCAT Expression_sequence
                    //  | Expression_unknown
                      ;

Expression_dictionary ::= Literal_dictionary
                     //   | Expression_unknown
                        ;

/*Expression_string ::= Literal_string
                   // | Expression_unknown
                    ;*/

Expression_defined ::= Literal_defined
                     //| Expression_unknown
                     ;

Expression_variable ::= ID;

Expression_unknown ::= Expression_variable
                     | Expression_field_reference
                     | Expression_conditioned_function_call
                     | Expression_dictionary_key
                     | Expression_sequence_index
                     ;

Expression_pos_int_unknown ::= LIT_POS_INT
                 | Expression_int Operator_binary_numeric Expression_int
                 | Expression_sequence_length
                 | Expression_unknown
                 ;

// functions and fields
Expression_function_predicate ::= QUES_MARK Expression_boolean QUES_MARK;

Expression_function_call ::= ID BRACKET_L Expression_list BRACKET_R;

Expression_conditioned_function_call ::= Expression_function_predicate Expression_function_call;

Expression_field_reference ::= Expression_defined DOT ID;

Expression_sequence_length ::= Expression_sequence DOT LEN;

// aggregate type value reference
Expression_dictionary_key ::= Expression_dictionary BRACKET_SL Expression BRACKET_SR;

Expression_sequence_index ::= Expression_sequence BRACKET_SL Expression_int BRACKET_SR;

// sequence slice
Expression_sequence_slice ::= Expression_sequence_left_slice
                            | Expression_sequence_right_slice
                            | Expression_sequence_dual_slice
                            | Expression_sequence_empty_slice
                            ;

Expression_sequence_left_slice  ::= Expression_sequence BRACKET_SL Expression_pos_int_unknown COLON BRACKET_SR;
Expression_sequence_right_slice ::= Expression_sequence BRACKET_SL COLON Expression_int BRACKET_SR;
Expression_sequence_dual_slice  ::= Expression_sequence BRACKET_SL Expression_pos_int_unknown COLON Expression_int BRACKET_SR;
Expression_sequence_empty_slice ::= Expression_sequence BRACKET_SL COLON BRACKET_SR;



// ----LITERALS----
/*Literal ::= Literal_inbuilt
          | Literal_defined
          ;*/

/*Literal_inbuilt ::= Literal_Integer
          | Literal_dictionary
          | Literal_sequence
          | Literal_string
          ;*/

// primitive literals
Literal_Integer ::= LIT_POS_INT
                  | LIT_NEG_INT
                  ;

// aggregate literals
/*Literal_defined ::= Literal_inbuilt
                  | Literal_inbuilt COMMA Literal_defined
                  ;*/

Dictionary_entry ::= Expression COLON Expression;

Dictionary_entry_list ::= Dictionary_entry COMMA Dictionary_entry_list
                        | Dictionary_entry
                        ;

Literal_dictionary ::= CURLY_L Dictionary_entry_list CURLY_R
                     | CURLY_L CURLY_R
                     ;

Sequence_entry ::= Expression;

Sequence_entry_list ::= Sequence_entry COMMA Sequence_entry_list
                    | Sequence_entry
                    ;

Literal_sequence ::= BRACKET_SL Sequence_entry_list BRACKET_SR
                   | BRACKET_SL BRACKET_SR
                   | LIT_STRING
                   ;

// numerical literals
Literal_rational ::= LIT_RAT
                 //  | Literal_Integer
                   ;

Literal_float    ::= LIT_FLOAT
                //   | Literal_Integer
                   ;

// ----TYPES----
Type ::= Type_primitive
       | Type_aggregate
       | Type_defined
       | TOP
       ;

// Type grouping
Type_primitive ::= Type_number
                 | TYPE_CHAR
                 | TYPE_BOOL
                 ;

Type_number ::= TYPE_INT
              | TYPE_FLOAT
              | TYPE_RAT
              ;

Type_aggregate ::= Type_sequence
                 //| Type_string
                 | Type_dictionary
                 ;

Type_defined ::= ID; 

// aggregate types
Type_dictionary ::= DICT ANGLE_L Type_legal_dictionary_key COMMA Type_legal_dictionary_value ANGLE_R;

Type_sequence ::= SEQ ANGLE_L Type ANGLE_R
                | TYPE_STR;

// legal types
Type_legal_dictionary_key ::= Type;

//Type_legal_sequence_value ::= Type;

Type_legal_dictionary_value ::= Type;

/*Type_string ::= TYPE_STR
              | SEQ ANGLE_L TYPE_CHAR ANGLE_R
              ;*/

// ----OPERATORS----
/*Operator ::= Operator_binary_boolean
           | Operator_binary_comparison
           | Operator_binary_numeric
           | Operator_binary_sequence
          // | Operator_binary_dictionary
           | Operator_unary_boolean
           ;*/

// binary
Operator_binary_boolean ::= AND
                          | OR
                          | IMPLIES
                          ;

Operator_binary_comparison ::= ANGLE_L // less than
                             | LESS_OR_EQ
                             | EQUAL
                             | NOT_EQUAL
                             ;

Operator_binary_numeric ::= PLUS
                          | MINUS
                          | MULTIPLY
                          | DIVIDE
                          | POWER
                          ;

/*Operator_binary_sequence ::= IN
                           | CONCAT
                           ;*/

//Operator_binary_dictionary ::= IN;

// unary
//Operator_unary_boolean ::= NOT;



































             