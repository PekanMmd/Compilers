// Parser by Megan Lucas, Nadia Mahgerefteh and Stars Momodu
import java_cup.runtime.*;
import Lexer.java;

parser code {:

  Boolean syntaxErrors = false;
  Lexer lexer;

  public Parser(Lexer lex) {
    this.lexer = lex;
  } 

  public void syntax_error(Symbol current_token) { report_error(
     "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null );
  }
:}

scan with {: return lexer.next_token(); :};

/* -----------------------------------------------------------------------------------------
 * Terminals
 * -----------------------------------------------------------------------------------------
 */

// ----OTHER----
terminal ERROR, ID, LEN;


// ----PUNCTUATION----

      //  Brackets
      terminal  BRACKET_L, BRACKET_R, BRACKET_SL, BRACKET_SR, ANGLE_R, ANGLE_L, CURLY_R, CURLY_L;
      
      //  Other
      terminal  SEMICOLON, COLON, DOT, COMMA, QUES_MARK;     


// ----KEYWORDS----

      //  Declaration
      terminal  ALIAS, TDEF, FDEF, MAIN;

      //  Control Flow
      terminal  IF, FI, THEN, ELSE, LOOP, POOL, RETURN, BREAK;
      
      //  IO
      terminal  READ, PRINT;


// ----DATA TYPES----

      //  Primitive
      terminal  TYPE_BOOL, TYPE_INT, TYPE_FLOAT, TYPE_RAT, TYPE_CHAR;

      //  Aggregate
      terminal  TYPE_STRING, DICT, SEQ;

      //  Other
      terminal  TOP;

// ----LITERALS----

      //  Primitive
      terminal  LIT_BOOL, LIT_INT, LIT_CHAR, LIT_FLOAT, LIT_RAT;

      //  Aggregate
      terminal  LIT_STRING;

      //  Other
      terminal  NULL;

// ----OPERATORS----

      //  Boolean Operators
      terminal  NOT, AND, OR, IMPLIES;

      //  Numeric Operators
      terminal  PLUS, MINUS, MULTIPLY, DIVIDE, POWER;

      //  Dictionary/Sequence Operators
      terminal  IN, CONCAT;

      //  Comparison Operators
      terminal  LESS_THAN, LESS_OR_EQ, EQUAL, NOT_EQUAL;

      //  Other
      terminal ASSIGNMENT;

      
/* -----------------------------------------------------------------------------------------
 * Non Terminals
 * -----------------------------------------------------------------------------------------
 */



// ----˜Z PROGRAM----
  non terminal        Z_Program;



// ----DECLARATIONS----
  non terminal        Declaration, Declaration_list;

  // functions
  non terminal        Declaration_function, Declaration_main;

  // types
  non terminal        Declaration_type, Declaration_type_alias;

  // parameters
  non terminal        Parameter_function, Parameter_list_function, Parameter_type, Parameter_list_type;

  // variables
  non terminal        Declaration_variable, Declaration_variable_assignment;



// ----FUNCTION DECLARATIONS----
  non terminal        Function_body, Main_body;

  // legal declarations
  non terminal        Legal_declaration_function, Legal_declaration_list_function, Legal_declaration_main, Legal_declaration_list_main;



// ----STATEMENTS----
  non terminal        Statement, Statement_list;

  // control flow
  non terminal        Statement_if, Statement_if_else, Statement_loop;

  // actions
  non terminal        Statement_return, Statement_break, Statement_assignment, Statement_conditioned_function_call;

  // input/output
  non terminal        Statement_IO, Statement_input, Statement_output;



// ----EXPRESSIONS----
  non terminal        Expression, Expression_list;

  // operators
  non terminal        Expression_boolean, Expression_comparison, Expression_numeric, Expression_sequence, Expression_int, Expression_rat, Expression_float, Expression_unknown;

  // functions and fields
  non terminal        Expression_function_predicate, Expression_function_call, Expression_conditioned_function_call, Expression_field_reference;

  // aggregate type value reference
  non terminal        Expression_dictionary_key, Expression_sequence_index; 

  // sequence slice
  non terminal        Expression_sequence_slice, Expression_sequence_left_slice, Expression_sequence_right_slice, Expression_sequence_dual_slice, Expression_sequence_empty_slice;



// ----LITERALS----
  non terminal        Literal;

  // aggregate literals
  non terminal        Literal_dictionary, Literal_sequence, Literal_string;



// ----TYPES----
  non terminal        Type; 

  // Type grouping
  non terminal        Type_primitive, Type_number, Type_aggregate, Type_defined, Type_int; // defined type includes aliases

  // aggregate types
  non terminal        Type_dictionary, Type_sequence;

  // legal types
  non terminal        Type_legal_dictionary_key, Type_legal_dictionary_value, Type_legal_sequence_value;



// ----OPERATORS----

  non terminal        Operator;

  // binary
  non terminal        Operator_binary_boolean, Operator_binary_comparison, Operator_binary_numeric, Operator_binary_sequence;

  // unary
  non terminal        Operator_unary_boolean


/* -----------------------------------------------------------------------------------------
 * Precedences
 * -----------------------------------------------------------------------------------------
 */
//precedence left PLUS, MINUS;

/* -----------------------------------------------------------------------------------------
 * Rules
 * -----------------------------------------------------------------------------------------
 */


// Stars

// ----˜Z PROGRAM----
Z_Program ::= Declaration_main
            | Declaration_main Declaration_list
            | Declaration_list Declaration_main
            | Declaration_list Declaration_main Declaration_list
            ;
       
// ----DECLARATIONS----
Declaration ::= Declaration_function
              | Declaration_type
              | Declaration_type_alias
              | Declaration_variable
              | Declaration_variable_assignment
              ;

Declaration_list ::= Declaration Declaration_list
                   | Declaration
                   ;


// functions
Declaration_function;

Declaration_main ::= MAIN CURLY_L Main_body CURLY_R SEMICOLON;

// types
Declaration_type;

Declaration_type_alias;

// parameters
Parameter_function;
Parameter_list_function;
Parameter_type;
Parameter_list_type;

// variables
Declaration_variable;
Declaration_variable_assignment;


// ----FUNCTION DECLARATIONS----
Function_body;

Main_body;

// legal declarations
Legal_declaration_function ::= Declaration_variable
                             | Declaration_variable_assignment
                             ;

Legal_declaration_list_function;

Legal_declaration_main ::= Declaration_variable
                         | Declaration_variable_assignment
                         ;

Legal_declaration_list_main;


// ----STATEMENTS----
Statement;
Statement_list;

// control flow
Statement_if;
Statement_if_else;
Statement_loop;

// actions
Statement_return;
Statement_break;
Statement_assignment;
Statement_conditioned_function_call;

// input/output
Statement_IO;
Statement_input;
Statement_output;

// ----EXPRESSIONS----
Expression ::= ;

// operators
Expression_boolean ::= LIT_BOOL
                     | Expression_boolean Operator_binary_boolean Expression_boolean
                     | Operator_unary_boolean Expression_boolean
                     | Expression_unknown
                     ;



Expression_comparison;
Expression_numeric;
Expression_sequence;

// functions and fields
Expression_function_predicate;
Expression_function_call;
Expression_conditioned_function_call;
Expression_field_reference;

// aggregate type value reference
Expression_dictionary_key;
Expression_sequence_index; 

// sequence slice
Expression_sequence_slice;
Expression_sequence_left_slice;
Expression_sequence_right_slice;
Expression_sequence_dual_slice;
Expression_sequence_empty_slice;



// ----LITERALS----
Literal;

// aggregate literals
Literal_dictionary;
Literal_sequence;
Literal_string;



// ----TYPES----
Type; 

// Type grouping
Type_primitive;
Type_number;
Type_aggregate;
Type_defined;
Type_int;

// aggregate types
Type_dictionary;
Type_sequence;

// legal types
Type_legal_dictionary_key;
Type_legal_dictionary_value;
Type_legal_sequence_value;




// ----OPERATORS----
Operator;

// binary
Operator_binary_boolean;
Operator_binary_comparison;
Operator_binary_numeric;
Operator_binary_sequence;

// unary
Operator_unary_boolean ::= NOT;

// Yaya



























             