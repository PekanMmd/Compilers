// Parser by Megan Lucas, Nadia Mahgerefteh and Stars Momodu
import java_cup.runtime.*;
import Lexer.java;

parser code {:

  Boolean syntaxErrors = false;
  Lexer lexer;

  public Parser(Lexer lex) {
    this.lexer = lex;
  } 

  public void syntax_error(Symbol current_token) { report_error(
     "Syntax error at line " + (current_token.left+1) + ", column " + current_token.right, null );
  }
:}

scan with {: return lexer.next_token(); :};

/* -----------------------------------------------------------------------------------------
 * Terminals
 * -----------------------------------------------------------------------------------------
 */

// ----OTHER----
terminal ERROR, ID, LEN;


// ----PUNCTUATION----

      //  Brackets
      terminal  BRACKET_L, BRACKET_R, BRACKET_SL, BRACKET_SR, ANGLE_R, ANGLE_L, CURLY_R, CURLY_L;
      
      //  Other
      terminal  SEMICOLON, COLON, DOT, COMMA, QUES_MARK;     


// ----KEYWORDS----

      //  Declaration
      terminal  ALIAS, TDEF, FDEF, MAIN;

      //  Control Flow
      terminal  IF, FI, THEN, ELSE, LOOP, POOL, RETURN, BREAK;
      
      //  IO
      terminal  READ, PRINT;


// ----DATA TYPES----

      //  Primitive
      terminal  TYPE_BOOL, TYPE_INT, TYPE_FLOAT, TYPE_RAT, TYPE_CHAR;

      //  Aggregate
      terminal  TYPE_STR, DICT, SEQ;

      //  Other
      terminal  TOP;

// ----LITERALS----

      //  Primitive
      terminal  VAL_BOOL, LIT_POS_INT, LIT_NEG_INT, LIT_CHAR, LIT_FLOAT, LIT_RAT;

      //  Aggregate
      terminal  LIT_STRING;

      //  Other
      terminal  NULL;

// ----OPERATORS----

      //  Boolean Operators
      terminal  NOT, AND, OR, IMPLIES;

      //  Numeric Operators
      terminal  PLUS, MINUS, MULTIPLY, DIVIDE, POWER;

      //  Dictionary/Sequence Operators
      terminal  IN, CONCAT;

      //  Comparison Operators
      terminal  LESS_THAN, LESS_OR_EQ, EQUAL, NOT_EQUAL;

      //  Other
      terminal ASSIGNMENT;

      
/* -----------------------------------------------------------------------------------------
 * Non Terminals
 * -----------------------------------------------------------------------------------------
 */



// ----˜Z PROGRAM----
  non terminal        Z_Program;



// ----DECLARATIONS----
  non terminal        Declaration, Declaration_list;

  // functions
  non terminal        Declaration_function, Declaration_main;

  // types
  non terminal        Declaration_type, Declaration_type_alias;

  // parameters
  non terminal        Parameter_function, Parameter_list_function, Parameter_type, Parameter_list_type;

  // variables
  non terminal        Declaration_variable, Declaration_variable_assignment;



// ----FUNCTION DECLARATIONS----
  non terminal        Function_body, Main_body;

  // legal declarations
  non terminal        Legal_declaration_function, Legal_declaration_list_function, Legal_declaration_main, Legal_declaration_list_main;



// ----STATEMENTS----

  non terminal        Statement, Statement_list;

  // control flow
  non terminal        Statement_if, Statement_if_else, Statement_loop;

  // actions
  non terminal        Statement_return, Statement_break, Statement_assignment, Statement_conditioned_function_call;

  // input/output
  non terminal        Statement_IO, Statement_input, Statement_output;



// ----EXPRESSIONS----
  non terminal        Expression, Expression_list;

  // operators
  non terminal        Expression_boolean, Expression_comparison, Expression_numeric, Expression_sequence, Expression_int, Expression_rat, Expression_float, Expression_unknown;

  // functions and fields
  non terminal        Expression_function_predicate, Expression_function_call, Expression_conditioned_function_call, Expression_field_reference;

  // aggregate type value reference
  non terminal        Expression_dictionary_key, Expression_sequence_index; 

  // sequence slice
  non terminal        Expression_sequence_slice, Expression_sequence_left_slice, Expression_sequence_right_slice, Expression_sequence_dual_slice, Expression_sequence_empty_slice;


// ----LITERALS----
  non terminal        Literal;

  // aggregate literals
  non terminal        Literal_dictionary, Literal_sequence, Literal_string;



// ----TYPES----
  non terminal        Type; 

  // Type grouping
  non terminal        Type_primitive, Type_number, Type_aggregate, Type_defined, Type_int; // defined type includes aliases

  // aggregate types
  non terminal        Type_dictionary, Type_sequence;

  // legal types
  non terminal        Type_legal_dictionary_key, Type_legal_dictionary_value, Type_legal_sequence_value;



// ----OPERATORS----

  non terminal        Operator;

  // binary
  non terminal        Operator_binary_boolean, Operator_binary_comparison, Operator_binary_numeric, Operator_binary_sequence;

  // unary
  non terminal        Operator_unary_boolean


/* -----------------------------------------------------------------------------------------
 * Precedences
 * -----------------------------------------------------------------------------------------
 */
//precedence left PLUS, MINUS;

/* -----------------------------------------------------------------------------------------
 * Rules
 * -----------------------------------------------------------------------------------------
 */


// Stars

// ----˜Z PROGRAM----
Z_Program ::= Declaration_main
            | Declaration_main Declaration_list
            | Declaration_list Declaration_main
            | Declaration_list Declaration_main Declaration_list
            ;
       
// ----DECLARATIONS----
Declaration ::= Declaration_function
              | Declaration_type
              | Declaration_type_alias
              | Declaration_variable
              | Declaration_variable_assignment
              ;

Declaration_list ::= Declaration Declaration_list
                   | Declaration
                   ;


// functions
Declaration_function ::= FDEF ID BRACKET_L Parameter_list_function BRACKET_R CURLY_L Function_body CURLY_R SEMICOLON 
                        | FDEF ID BRACKET_L Parameter_list_function BRACKET_R CURLY_L Function_body CURLY_R COLON Type SEMICOLON
                        ;

Declaration_main ::= MAIN CURLY_L Main_body CURLY_R SEMICOLON;

// types
Declaration_type ::= TDEF ID CURLY_L Parameter_list_type CURLY_R SEMICOLON;

Declaration_type_alias ::= ALIAS Type ID SEMICOLON;

// parameters
Parameter_function ::= ID COLON TYPE;

Parameter_list_function ::= Parameter_function COMMA Parameter_list_function
                          | Parameter_function;Parameter_type
                          ;

Parameter_list_type ::= Parameter_type COMMA Parameter_list_type 
                      | Parameter_type
                      ;
// variables
Declaration_variable ::= ID COLON TYPE;
Declaration_variable_assignment ::= ID COLON TYPE ASSIGNMENT Expression;


// ----FUNCTION DECLARATIONS----
Function_body ::= Legal_declaration_list_function Statement_list
                | Legal_declaration_list_function
                | Statement_list
                | 
                ;

Main_body ::= Legal_declaration_list_main Statement_list
            | Legal_declaration_list_main
            | Statement_list;
            | 
            ;

// legal declarations
Legal_declaration_function ::= Declaration_variable
                             | Declaration_variable_assignment
                             ;

Legal_declaration_list_function ::= Legal_declaration_function Legal_declaration_list_function
                                  | Legal_declaration_function
                                  ;

Legal_declaration_main ::= Declaration_variable
                         | Declaration_variable_assignment
                         ;

Legal_declaration_list_main ::= Legal_declaration_main Legal_declaration_list_main
                              | Legal_declaration_main
                              ;

// ----STATEMENTS----
Statement ::= Statement_Control_Flow
            | Statement_IO
            | Statement_assignment
            | Statement_conditioned_function_call
            ;

Statement_list ::= Statement Statement_list
                  | Statement
                  ;
// control flow
Statement_if ::= IF BRACKET_L Expression BRACKET_R THEN Function_body FI;
                                      
Statement_if_else ::= IF BRACKET_L Expression BRACKET_R THEN Function_body ELSE Function_body FI;

Statement_loop ::= LOOP Function_body POOL;

// actions
Statement_break ::= BREAK
                  | BREAK LIT_POS_INT
                  ;

Statement_return ::= RETURN Expression;

Statement_assignment ::= ID ASSIGNMENT Expression;

Statement_conditioned_function_call ::= Expression_function_predicate Expression_function_call SEMICOLON;

// input/output
Statement_IO ::= Statement_input
                | Statement_output;

Statement_input ::= READ ID;

Statement_output ::= PRINT Expression;

// ----EXPRESSIONS----
Expression ::= ;

// operators
Expression_boolean ::= LIT_BOOL
                     | Expression_boolean Operator_binary_boolean Expression_boolean
                     | Operator_unary_boolean Expression_boolean
                     | Expression_unknown
                     ;



Expression_comparison;
Expression_numeric;
Expression_sequence;

// functions and fields
Expression_function_predicate;
Expression_function_call;
Expression_conditioned_function_call;
Expression_field_reference;

// aggregate type value reference
Expression_dictionary_key;
Expression_sequence_index; 

// sequence slice
Expression_sequence_slice;
Expression_sequence_left_slice;
Expression_sequence_right_slice;
Expression_sequence_dual_slice;
Expression_sequence_empty_slice;



// ----LITERALS----
Literal;

// aggregate literals
Literal_dictionary;
Literal_sequence;
Literal_string;



// ----TYPES----
Type ::= Type_primitive
       | Type_aggregate
       | Type_defined
       | TOP;

// Type grouping
Type_primitive ::= Type_number
                  | TYPE_CHAR
                  | TYPE_BOOL
                  ;

Type_number ::= TYPE_INT
              | TYPE_FLOAT
              | TYPE_RAT
              ;

Type_aggregate ::= Type_string
                 | Type_sequence
                 | Type_dictionary
                 ;

Type_defined ::= ID; 

// aggregate types
Type_dictionary ::= DICT ANGLE_L Type COMMA Type ANGLE_R;

Type_sequence ::= SEQ ANGLE_L Type ANGLE_R;

// legal types
Type_legal_dictionary_key ::= Type;

Type_legal_sequence_value ::= Type;

Type_legal_dictionary_value ::= Type;

Type_string ::= TYPE_STR
              | SEQ ANGLE_L TYPE_CHAR ANGLE_R
              ;

// ----OPERATORS----
Operator ::= Operator_binary_boolean;
            | Operator_binary_comparison;
            | Operator_binary_numeric;
            | Operator_binary_sequence
            ;

// binary
Operator_binary_boolean ::= AND
                          | OR
                          | IMPLIES
                          ;

Operator_binary_comparison;
Operator_binary_numeric;
Operator_binary_sequence;

// unary
Operator_unary_boolean ::= NOT;

// Yaya



































             